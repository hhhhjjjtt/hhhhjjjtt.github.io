[{"content":"Introduction\rOver the summer, I started teaching myself FPGA stuff.\nHonestly, at first I barely knew what an FPGA was or why people used it. Two friends were into it, so I thought: why not try something new and see where it goes? I bought a PYNQ-Z2 board and just started poking around. Blink an LED, drive some pins, write tiny Verilog\u0026hellip; all are some basic things to get a feel.\nLuckily, that random decision actually helped me land my first internship in chip testing in lab. Most days I were either writting and debugging SystemVerilog testbenches, or building on some Python drivers for a function generator. Nothing fancy, but it was really helpful in forcing me to read real waveforms, plan about timing, and kind of think in a way \u0026ldquo;hardware programming\u0026rdquo; does. From there, I started to see a clearer and bigger picture about the IC world.\nBy the end of the summer I was more comfortable with Verilog, so I wanted to build on a project that felt ‚Äúreal,‚Äù not just a demo. A CPU sounded scary in a good way: it is big enough for me to spend days and night on studying it, but also small enough for me to really finish it without abandoning. Also, I‚Äôd seen single-cycle and pipelined CPUs in Computer System and Organization class, and I built a tiny 8-bit CPU for my Digital Logic Design class, but those felt either too theoretical or too toy-like. I wanted to build something that\u0026rsquo;s a few steps closer to the real world.\nSo I decided on RISC-V, 32-bit Base Integer Instruction Set (RV32I). RISC-V is open source, with clean instructions, and a lot of examples to learn from. I spend a little time reading docs, lecture notes, and hobby cores, and from these readings I began to plan what my own core\u0026rsquo;s gonna look like. And finally, inspired by the project tinyriscv, I decided to build an in-order, 3-stage pipelined RV32I core with synchronous ROM/RAM, branch resolution in EX, and simple hazard handling (load-use stall, taken-branch flush).\n\u0026mdash;-I\u0026rsquo;ll explain what these means later, just in case.\nA few references helped a lot:\ntinyriscv: provided a reference for how 3-stage pipeline works.\nhttps://github.com/liangkangnan/tinyriscv OPENMIPS (from Write a CPU Yourself): 5 stage pipeline in MIPS with good modular structure, clear hold/flush patterns\nhttps://github.com/yufeiran/OpenMIPS NJUCS 2023 DLCO official course website: useful datapath and lab guidance\nhttps://nju-projectn.github.io/dlco-lecture-note/exp/11.html So that‚Äôs the story of why I‚Äôm doing this and how I got here. The rest on the post will give a short overview of the core.\nOverview\rRISC-V and RV32I\rJust a little background: RISC‚ÄëV is an open instruction set architecture (ISA). It‚Äôs modular: you start with a base ISA and add extensions.\nRISC-V have many subsets, and among them, RV32I is the 32‚Äëbit base integer ISA‚Äîno mul/div, no atomics, no floating‚Äëpoint.\nA few fast facts about RV32I:\n32 general‚Äëpurpose registers x0..x31; x0 is hard‚Äëwired to 0.\nLittle‚Äëendian memory, naturally aligned accesses in the base spec.\nSix instruction formats: R, I, S, B, U, J (you‚Äôll see these all over my decoder).\nThat‚Äôs enough to build real programs, test hazards, and run small benchmarks.\nWhat this project is (and isn‚Äôt)\rGoal: a minimal, well‚Äëcommented, 3‚Äëstage pipelined RV32I core in Verilog that runs hand‚Äëassembled tests and demonstrates robust hazard handling.\nNot a goal (yet): exceptions/CSRs, caches, or branch prediction. This core I make is mainly a learning core.\nArchetecture Overview\rKey choices:\nSynchronous ROM/RAM: addresses are presented in cycle N; data becomes visible in cycle N+1. This strongly shapes IF/ID timing.\nControl bundle from ID to EX: a 16‚Äëbit bus from ID to EX stage that passes neccesarry decoded control information about ALU operation, branch control, and memory operation. Looks like this:\n1 { REG_we, SRC_A, SRC_B[1:0], ALU[3:0], BRANCH[2:0], MemToReg, MEM_we, MEM_op[2:0] } Branches resolved in EX: taken branches flush the wrong‚Äëpath instructions early, and redirect the PC address to the branch destination.\nLoad‚Äëuse stall: upon a load operation, pipeline will be hold for one beat to let the read from data ram complete; writeback occurs on the next beat.\nSource File Overview\rdefines.v: Defines Macros like buses, opcodes, funct3/7, the 16‚Äëbit control encoding, etc.\npc.v: PC pointer. Have three behaviors: jump, hold, or +4.\nSequential logic inst_rom.v: Instruction rom. Able to do syncronous read and write; memories with addr[31:2] drop (enforces word alignment).\nSequential logic data_ram.v: Data ram. Able to do syncronous read and write; memories with addr[31:2] drop (enforces word alignment).\nSequential logic regs.v: 32√ó32 regfile, synchronous write, combinational reads with simple WB‚Äëbypass.\nCombinational logic id.v: Decoder builds immediates (I/S/B/U/J), selects ALU ops, sets branch class, memory width/sign, and MemToReg.\nCombinational logic if_id.v: Pipeline latch between if and id. Flush and hold behavior is controlled by hold_ctrl.v. Instruction Rom is integrated inside of if_id.v instead of placing along with pc.v before if_id.v it to prevent an extra clock cycle in id stage.\nSequential logic id_ex.v: Pipeline latch between id and ex. Flush and hold behavior is controlled by hold_ctrl.v.\nSequential logic ex.v: handles the ALU; branch target/decision; data‚Äëwidth packing/unpacking for loads/stores; extra load/WB two‚Äëbeat register; hazard control\nMainly combinational logic, but with a sequential logic load register that stores the load instruction (destination register address/write enable/write width/write source) during load operation hold_ctrl.v: translates EX‚Äôs {load_busy, branch_en} into the specific hold/flush flags for each stage.\nCombinational logic Data Hazard\rA hazard is anything that makes the pipeline do the wrong thing if we just keep marching forward one instruction per cycle. Hazards show up because instructions overlap in time.\nHazard Types\rData Hazards\rRAW (Read After Write): An instruction needs a value that a previous instruction hasn‚Äôt produced yet. Example:\n1 2 lw x3, 0(x1) # produces x3, but the data only arrives next cycle add x4, x3, x5 # needs x3 immediately WAR (Write After Read): a later instruction writes a register that an earlier instruction still needs to read. In an in‚Äëorder, single‚Äëissue pipeline like mine, WAR doesn‚Äôt occur (reads happen before later writes reach WB).\nWAW (Write After Write): two instructions write the same register; the older must ‚Äúwin.‚Äù Also avoided in in‚Äëorder, single‚Äëissue pipelines because writes retire in program order.\nControl Hazards\rBranches and jumps disrupt the fetch stream because we don‚Äôt know the correct next PC until EX resolves the condition/target.\n1 2 beq x1, x2, target # if taken, the instruction already fetched after this is wrong add x3, x4, x5 # wrong‚Äëpath Hazard Policies\rBranch: handled in EX stage When there is successful branch detected, ex.v will send a pipeline flush signal to hold_ctrl.v. pc.v will jump to the designated address, while if_id.v and id_ex.v will output NOP to the next stage. Which is equavalent to take a Branch while flushing the two falsely fetched instructions after Branch. Load: handled in EX stage When there is a load detected, ex.v will send a pipeline hold signal to hold_ctrl.v. pc.v and if_id.v will hold on to its current output value, while id_ex.v will output NOP. Which is equavalent to waiting for the data loaded from the data ram to be written to the register files. Read after Write: handled in register file Upon read after write, bypass the write value directly to the read. Running the CPU\rüèóÔ∏è under work\u0026hellip;\nGo to my github repo: https://github.com/hhhhjjjtt/my-riscv, follow the instruction there to build and run.\n","date":"2025-10-20T00:00:00Z","image":"https://hhhhjjjtt.github.io/p/blog_2025_10_20/img/pipeline_hu14588829514303417530.png","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_20/","title":"Building a Minimal RV32I CPU: Part 1"},{"content":"Introduction\rüèóÔ∏è Post under work‚Ä¶\ncheck the github repo first: https://github.com/hhhhjjjtt/UART\n","date":"2025-10-07T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_07/","title":"UART module"},{"content":"Introduction\rüèóÔ∏è Post under work‚Ä¶\ncheck the github repo first: https://github.com/hhhhjjjtt/HLS-CNN-MNIST\n","date":"2025-10-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_01/","title":"Deploying CNN in a PYNQ-Z2 board"},{"content":"Introduction\rThis mini project aims to implement the forward propagation algorithm of Neural Network in C. This is kind of like re-inventing the wheel, but I found it helpful in helping me learn about C and algorithms in ML.\nA Mininal Matrix Library\rSince Forward propagation involves multiplyitng layers with a weight matrix and adding a bias matrix, we need to handle matrix multiplication and addition.\nOther matrix operations minght be helpful, but now we only want to focus on a minimal implementation.\nWe will define a maatrix using the struct in c:\n1 2 3 4 5 typedef struct matrix{ int row; int col; float** data; } matrix; Where a matrix have row, column, and a 2-d array to store its data.\nWe will have functions to allocate memory to our matrix struct, as well as functions to clear them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Allcoate space, and initialize all element value in a matrix to 0 void matInitZero(matrix* input, int row, int col){ input-\u0026gt;row = row; input-\u0026gt;col = col; input-\u0026gt;data = malloc(row * sizeof(float*)); for(int i = 0; i \u0026lt; row; i++){ input-\u0026gt;data[i] = malloc(col * sizeof(float)); for(int j = 0; j \u0026lt; col; j++){ input-\u0026gt;data[i][j] = 0; } } } // Free the memory allocated void matFree(matrix* input){ for(int i = 0; i \u0026lt; input-\u0026gt;row; i++){ free(input-\u0026gt;data[i]); } free(input-\u0026gt;data); } To be continued\u0026hellip;\n","date":"2024-11-12T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_12/","title":"Implementing Forward propagation in C"},{"content":"Introduction\rIn this mini project, we will be using OpenCV as for our image processing, then sned the processed image through uart communication to an Arduino UNO R3 board to be displayed on an max7219 8 x 8 LED display. I\u0026rsquo;ve posted the project repo here\nPython Setup\rFor the python script, We first want to make sure to import the libraries we need\n1 2 import cv2 as cv import serial I will use the Video Bad Apple as an example. The video is 480*360 in size, so to display it on an 8 x 8 screen, we have to compress it.\nWe can achive this by using OpenCV\u0026rsquo;s resize() method\n1 frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) Then, since the led can\u0026rsquo;t display in RGB, it would be benificial to convert the frame to Grayscale, then to a binary scale. In that way, we can use on/off of the led to diaplay the graphics\n1 2 gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) we can write these operations as\n1 2 3 4 5 def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame To transfer the frame data to Arduino via uart communication, we can convert the 8 x 8 frame to an binary array:\n1 2 3 4 5 6 7 8 def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array This array can be then sent to the Arduino board via uart communication\n1 2 3 binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) ser.write(bytearray(frame_bytes)) The full python code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import cv2 as cv import serial # To check: first open device manager, then look for \u0026#39;Ports\u0026#39; # and see which port Arduino is connected to ser = serial.Serial(\u0026#39;COM8\u0026#39;, 9600) # Compress a video frame to 8*8 binary freme def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame # Convert frame to binary array def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array capture = cv.VideoCapture(\u0026#39;bad_apple.mp4\u0026#39;) print(\u0026#34;Press \\\u0026#34;d\\\u0026#34; to stop\u0026#34;) while True: isTrue, frame = capture.read() if not isTrue: break # Process each frame binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) # Transmit frame bytes to Arduino ser.write(bytearray(frame_bytes)) enlarged_frame = cv.resize(binary_frame * 255, (160, 160), interpolation=cv.INTER_NEAREST) cv.imshow(\u0026#39;Enlarged 8x8 Video\u0026#39;, enlarged_frame) cv.imshow(\u0026#39;original Video\u0026#39;, frame) if cv.waitKey(20) \u0026amp; 0xFF == ord(\u0026#39;d\u0026#39;): break empty_screen = [0] * 64 ser.write(bytearray(empty_screen)) capture.release() ser.close() cv.destroyAllWindows() Arduino Setup\rWe will be using the LedControl library found here.\nIn your Arduino IDE, start a new project.\nFirst, we need to connect the right pins to the right port. In this case, I choose pin 12 as DataIn, 11 as CLK, 10 as LOAD.\n1 2 // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); We want to start the buald rate at 9600, and clear the screen first.\n1 2 3 4 5 6 void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } Then, we want to listen to the data sent by the python script. Since each frame is 8x8=64 bit, each frame is consist of 8 bytes. Thus, we\u0026rsquo;ll start displaying once we have revieved 8 bytes.\n1 2 3 4 5 6 7 8 void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } The full cpp code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;LedControl.h\u0026gt; // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } ","date":"2024-11-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_01/","title":"Display Video on 8*8 LED screen using OpenCV + Arduino"},{"content":"Hello\rI\u0026rsquo;m Jefferson, this is my first blog.\n","date":"2024-10-21T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_10_21/","title":"My First Blog"}]