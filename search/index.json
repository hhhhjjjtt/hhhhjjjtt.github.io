[{"content":"Introduction\rOver the summer, I\u0026rsquo;ve spend time trying to teach myself about how a cpu is constructed.\nI already learned in Computer System and Organization about the machanisms behind both a single cycle and a pipelined cpu. I also have ecperience in building things up using verilog, but none of them (led, spi, uart\u0026hellip;) have the complexity of a cpu.\nSo, I\u0026rsquo;ve decided to build one on myself.\nI researched a bunch of RISC‑V docs, class notes, and hobbyist cores, tried a few pipeline sketches.\nThe three main references of my design is as such:\ntinyriscv: https://github.com/liangkangnan/tinyriscv\nmain design idea come from here, where I used the same three stage pipeline structure as he did. OPENMIPS: from the book write a CPU yourself https://github.com/yufeiran/OpenMIPS\nNJUCS 2023 Digital Logic and Computer Organization Course Project: https://nju-projectn.github.io/dlco-lecture-note/exp/11.html\nI finally settled on a 3‑stage design:\nIF: fetch from instruction ROM, manage the PC\nID: decode, read registers, build immediates, package a control bundle\nEX+MEM+WB: execute ALU ops, do data RAM reads/writes, and commit results\nI made instruction rom and data ram both syncronous read, and data hazard mainly solved by pipeline holding and pipeline flushing.\nRISC-V and RV32I\rJust a little background: RISC‑V is an open instruction set architecture (ISA). It’s modular: you start with a base ISA and add extensions.\nRISC-V have many subsets, and among them, RV32I is the 32‑bit base integer ISA—no mul/div, no atomics, no floating‑point.\nA few fast facts about RV32I:\n32 general‑purpose registers x0..x31; x0 is hard‑wired to 0.\nLittle‑endian memory, naturally aligned accesses in the base spec.\nSix instruction formats: R, I, S, B, U, J (you’ll see these all over my decoder).\nThat’s enough to build real programs, test hazards, and run small benchmarks.\nWhat this project is (and isn’t)\rGoal: a minimal, well‑commented, 3‑stage pipelined RV32I core in Verilog that runs hand‑assembled tests and demonstrates robust hazard handling.\nNot a goal (yet): exceptions/CSRs, caches, or branch prediction. This core I make is mainly a learning core.\nArchetecture Overview\rSource File Overview\rdefines.v: defines Macros like buses, opcodes, funct3/7, the 16‑bit control encoding, etc.\npc.v: PC pointer. Have three behaviors: jump, hold, or +4.\ninst_rom.v/ data_ram.v: syncronous read and write; memories with addr[31:2] drop (enforces word alignment).\nregs.v: 32×32 regfile, synchronous write, combinational reads with simple WB‑bypass.\nid.v: decoder builds immediates (I/S/B/U/J), selects ALU ops, sets branch class, memory width/sign, and MemToReg.\nid_ex.v / if_id.v: pipeline latches with flush and hold behavior.\nex.v: ALU + branch target/decision + data‑width packing/unpacking for loads/stores + extra load/WB two‑beat register + hazard control\nhold_ctrl.v: translates EX’s {load_busy, branch_en} into the specific hold/flush flags for each stage.\nHazard Policy\rBranch: handled in EX stage When there is successful branch detected, ex.v will send a pipeline flush signal to hold_ctrl.v. pc.v will jump to the designated address, while if_id.v and id_ex.v will output NOP to the next stage. Which is equavalent to take a Branch while flushing the two falsely fetched instructions after Branch. Load: handled in EX stage When there is a load detected, ex.v will send a pipeline hold signal to hold_ctrl.v. pc.v and if_id.v will hold on to its current output value, while id_ex.v will output NOP. Which is equavalent to waiting for the data loaded from the data ram to be written to the register files. Read after Write: handled in register file Upon read after write, bypass the write value directly to the read. ","date":"2025-10-20T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_20/","title":"Building a Minimal RV32I CPU: Part 1-Focus"},{"content":"Introduction\r","date":"2025-10-07T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_07/","title":"UART module"},{"content":"Introduction\r","date":"2025-10-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_01/","title":"Deploying CNN in a PYNQ-Z2 board"},{"content":"Introduction\rThis mini project aims to implement the forward propagation algorithm of Neural Network in C. This is kind of like re-inventing the wheel, but I found it helpful in helping me learn about C and algorithms in ML.\nA Mininal Matrix Library\rSince Forward propagation involves multiplyitng layers with a weight matrix and adding a bias matrix, we need to handle matrix multiplication and addition.\nOther matrix operations minght be helpful, but now we only want to focus on a minimal implementation.\nWe will define a maatrix using the struct in c:\n1 2 3 4 5 typedef struct matrix{ int row; int col; float** data; } matrix; Where a matrix have row, column, and a 2-d array to store its data.\nWe will have functions to allocate memory to our matrix struct, as well as functions to clear them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Allcoate space, and initialize all element value in a matrix to 0 void matInitZero(matrix* input, int row, int col){ input-\u0026gt;row = row; input-\u0026gt;col = col; input-\u0026gt;data = malloc(row * sizeof(float*)); for(int i = 0; i \u0026lt; row; i++){ input-\u0026gt;data[i] = malloc(col * sizeof(float)); for(int j = 0; j \u0026lt; col; j++){ input-\u0026gt;data[i][j] = 0; } } } // Free the memory allocated void matFree(matrix* input){ for(int i = 0; i \u0026lt; input-\u0026gt;row; i++){ free(input-\u0026gt;data[i]); } free(input-\u0026gt;data); } To be continued\u0026hellip;\n","date":"2024-11-12T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_12/","title":"Implementing Forward propagation in C"},{"content":"Introduction\rIn this mini project, we will be using OpenCV as for our image processing, then sned the processed image through uart communication to an Arduino UNO R3 board to be displayed on an max7219 8 x 8 LED display. I\u0026rsquo;ve posted the project repo here\nPython Setup\rFor the python script, We first want to make sure to import the libraries we need\n1 2 import cv2 as cv import serial I will use the Video Bad Apple as an example. The video is 480*360 in size, so to display it on an 8 x 8 screen, we have to compress it.\nWe can achive this by using OpenCV\u0026rsquo;s resize() method\n1 frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) Then, since the led can\u0026rsquo;t display in RGB, it would be benificial to convert the frame to Grayscale, then to a binary scale. In that way, we can use on/off of the led to diaplay the graphics\n1 2 gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) we can write these operations as\n1 2 3 4 5 def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame To transfer the frame data to Arduino via uart communication, we can convert the 8 x 8 frame to an binary array:\n1 2 3 4 5 6 7 8 def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array This array can be then sent to the Arduino board via uart communication\n1 2 3 binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) ser.write(bytearray(frame_bytes)) The full python code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import cv2 as cv import serial # To check: first open device manager, then look for \u0026#39;Ports\u0026#39; # and see which port Arduino is connected to ser = serial.Serial(\u0026#39;COM8\u0026#39;, 9600) # Compress a video frame to 8*8 binary freme def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame # Convert frame to binary array def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array capture = cv.VideoCapture(\u0026#39;bad_apple.mp4\u0026#39;) print(\u0026#34;Press \\\u0026#34;d\\\u0026#34; to stop\u0026#34;) while True: isTrue, frame = capture.read() if not isTrue: break # Process each frame binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) # Transmit frame bytes to Arduino ser.write(bytearray(frame_bytes)) enlarged_frame = cv.resize(binary_frame * 255, (160, 160), interpolation=cv.INTER_NEAREST) cv.imshow(\u0026#39;Enlarged 8x8 Video\u0026#39;, enlarged_frame) cv.imshow(\u0026#39;original Video\u0026#39;, frame) if cv.waitKey(20) \u0026amp; 0xFF == ord(\u0026#39;d\u0026#39;): break empty_screen = [0] * 64 ser.write(bytearray(empty_screen)) capture.release() ser.close() cv.destroyAllWindows() Arduino Setup\rWe will be using the LedControl library found here.\nIn your Arduino IDE, start a new project.\nFirst, we need to connect the right pins to the right port. In this case, I choose pin 12 as DataIn, 11 as CLK, 10 as LOAD.\n1 2 // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); We want to start the buald rate at 9600, and clear the screen first.\n1 2 3 4 5 6 void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } Then, we want to listen to the data sent by the python script. Since each frame is 8x8=64 bit, each frame is consist of 8 bytes. Thus, we\u0026rsquo;ll start displaying once we have revieved 8 bytes.\n1 2 3 4 5 6 7 8 void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } The full cpp code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;LedControl.h\u0026gt; // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } ","date":"2024-11-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_01/","title":"Display Video on 8*8 LED screen using OpenCV + Arduino"},{"content":"Hello\rI\u0026rsquo;m Jefferson, this is my first blog.\n","date":"2024-10-21T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_10_21/","title":"My First Blog"}]