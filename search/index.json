[{"content":"Introduction\r","date":"2025-10-20T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_20/","title":"Three-Stage Pipelined RISC-V Processor"},{"content":"Introduction\r","date":"2025-10-07T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_07/","title":"UART module"},{"content":"Introduction\r","date":"2025-10-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2025_10_01/","title":"Deploying CNN in a PYNQ-Z2 board"},{"content":"Introduction\rThis mini project aims to implement the forward propagation algorithm of Neural Network in C. This is kind of like re-inventing the wheel, but I found it helpful in helping me learn about C and algorithms in ML.\nA Mininal Matrix Library\rSince Forward propagation involves multiplyitng layers with a weight matrix and adding a bias matrix, we need to handle matrix multiplication and addition.\nOther matrix operations minght be helpful, but now we only want to focus on a minimal implementation.\nWe will define a maatrix using the struct in c:\n1 2 3 4 5 typedef struct matrix{ int row; int col; float** data; } matrix; Where a matrix have row, column, and a 2-d array to store its data.\nWe will have functions to allocate memory to our matrix struct, as well as functions to clear them:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Allcoate space, and initialize all element value in a matrix to 0 void matInitZero(matrix* input, int row, int col){ input-\u0026gt;row = row; input-\u0026gt;col = col; input-\u0026gt;data = malloc(row * sizeof(float*)); for(int i = 0; i \u0026lt; row; i++){ input-\u0026gt;data[i] = malloc(col * sizeof(float)); for(int j = 0; j \u0026lt; col; j++){ input-\u0026gt;data[i][j] = 0; } } } // Free the memory allocated void matFree(matrix* input){ for(int i = 0; i \u0026lt; input-\u0026gt;row; i++){ free(input-\u0026gt;data[i]); } free(input-\u0026gt;data); } To be continued\u0026hellip;\n","date":"2024-11-12T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_12/","title":"Implementing Forward propagation in C"},{"content":"Introduction\rIn this mini project, we will be using OpenCV as for our image processing, then sned the processed image through uart communication to an Arduino UNO R3 board to be displayed on an max7219 8 x 8 LED display. I\u0026rsquo;ve posted the project repo here\nPython Setup\rFor the python script, We first want to make sure to import the libraries we need\n1 2 import cv2 as cv import serial I will use the Video Bad Apple as an example. The video is 480*360 in size, so to display it on an 8 x 8 screen, we have to compress it.\nWe can achive this by using OpenCV\u0026rsquo;s resize() method\n1 frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) Then, since the led can\u0026rsquo;t display in RGB, it would be benificial to convert the frame to Grayscale, then to a binary scale. In that way, we can use on/off of the led to diaplay the graphics\n1 2 gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) we can write these operations as\n1 2 3 4 5 def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame To transfer the frame data to Arduino via uart communication, we can convert the 8 x 8 frame to an binary array:\n1 2 3 4 5 6 7 8 def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array This array can be then sent to the Arduino board via uart communication\n1 2 3 binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) ser.write(bytearray(frame_bytes)) The full python code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import cv2 as cv import serial # To check: first open device manager, then look for \u0026#39;Ports\u0026#39; # and see which port Arduino is connected to ser = serial.Serial(\u0026#39;COM8\u0026#39;, 9600) # Compress a video frame to 8*8 binary freme def rescale_to_8_8_binary(frame, threshold=127): frame = cv.resize(frame, (8, 8), interpolation=cv.INTER_AREA) gray_frame = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) _, binary_frame = cv.threshold(gray_frame, threshold, 1, cv.THRESH_BINARY) return binary_frame # Convert frame to binary array def binary_frame_to_bytes(binary_frame): byte_array = [] for row in binary_frame: byte = 0 for bit in row: byte = (byte \u0026lt;\u0026lt; 1) | bit byte_array.append(byte) return byte_array capture = cv.VideoCapture(\u0026#39;bad_apple.mp4\u0026#39;) print(\u0026#34;Press \\\u0026#34;d\\\u0026#34; to stop\u0026#34;) while True: isTrue, frame = capture.read() if not isTrue: break # Process each frame binary_frame = rescale_to_8_8_binary(frame) frame_bytes = binary_frame_to_bytes(binary_frame) # Transmit frame bytes to Arduino ser.write(bytearray(frame_bytes)) enlarged_frame = cv.resize(binary_frame * 255, (160, 160), interpolation=cv.INTER_NEAREST) cv.imshow(\u0026#39;Enlarged 8x8 Video\u0026#39;, enlarged_frame) cv.imshow(\u0026#39;original Video\u0026#39;, frame) if cv.waitKey(20) \u0026amp; 0xFF == ord(\u0026#39;d\u0026#39;): break empty_screen = [0] * 64 ser.write(bytearray(empty_screen)) capture.release() ser.close() cv.destroyAllWindows() Arduino Setup\rWe will be using the LedControl library found here.\nIn your Arduino IDE, start a new project.\nFirst, we need to connect the right pins to the right port. In this case, I choose pin 12 as DataIn, 11 as CLK, 10 as LOAD.\n1 2 // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); We want to start the buald rate at 9600, and clear the screen first.\n1 2 3 4 5 6 void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } Then, we want to listen to the data sent by the python script. Since each frame is 8x8=64 bit, each frame is consist of 8 bytes. Thus, we\u0026rsquo;ll start displaying once we have revieved 8 bytes.\n1 2 3 4 5 6 7 8 void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } The full cpp code is shown as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;LedControl.h\u0026gt; // Pin for MAX7219: DataIn, CLK, LOAD, # of MAX7219s LedControl lc = LedControl(12, 11, 10, 1); void setup() { Serial.begin(9600); lc.shutdown(0, false); lc.setIntensity(0, 8); lc.clearDisplay(0); } void loop() { if (Serial.available() \u0026gt;= 8) { // Wait until 8 bytes (1 frame) are available for (int i = 0; i \u0026lt; 8; i++) { byte rowData = Serial.read(); // Read each row byte lc.setRow(0, i, rowData); // Display the row on the LED matrix } } } ","date":"2024-11-01T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_11_01/","title":"Display Video on 8*8 LED screen using OpenCV + Arduino"},{"content":"Hello\rI\u0026rsquo;m Jefferson, this is my first blog.\n","date":"2024-10-21T00:00:00Z","permalink":"https://hhhhjjjtt.github.io/p/blog_2024_10_21/","title":"My First Blog"}]